{% extends 'base.html' %}
{% set title = 'تفاصيل التحدي' %}
@@
{% block content %}
<div class="row" style="justify-content:space-between;align-items:flex-end">
  <div>
    <h2 id="title" style="margin:0 0 6px">...</h2>
    <div class="muted" id="meta"></div>
  </div>
  <div class="row">
    <a class="btn" href="/challenges_ui">رجوع</a>
  </div>
</div>

<div id="msg" style="margin-top:12px"></div>

<style>
  .challenge-shell { max-width: 1200px; margin: 0 auto; }

  /* Vertical flow + spacing */
  .section { margin-top: 14px; }

  /* Solution split (primary focus on Blockly) */
  .solve-grid { display: flex; gap: 16px; align-items: stretch; }
  .solve-left { flex: 0 0 70%; min-width: 520px; }
  .solve-right { flex: 1 1 30%; min-width: 320px; }

  /* Ensure no clipping and enough space */
  .blockly-area { height: 650px; min-height: 650px; width: 100%; }
  #blocklyArea .blocklyToolboxDiv { width: 280px !important; }
  #blocklyArea .blocklyFlyout { width: 360px !important; }
  #blocklyArea .blocklyFlyoutBackground { width: 360px !important; }

  /* Submit area (separate from solution area) */
  .submit-area { margin-top: 14px; }
  .submit-btn { width: 100%; height: 56px; font-size: 18px; }

  @media (max-width: 1100px) {
    .solve-grid { flex-direction: column; }
    .solve-left, .solve-right { flex: 1 1 auto; min-width: 0; }
    .blockly-area { height: 520px; }
  }
</style>

<div class="challenge-shell section">
  <div class="panel pad">
    <h3 style="margin:0 0 8px">وصف التحدي</h3>
    <div class="muted" id="desc" style="line-height:1.9"></div>
    <div style="margin-top:12px" class="row" id="badges"></div>
  </div>

  <div class="panel pad section">
    <div class="row" style="justify-content:space-between;align-items:flex-end">
      <div>
        <h3 style="margin:0 0 6px">حل التحدي</h3>
        <div class="muted">ابنِ الحل باستخدام الكتل (Blockly) ثم اضغط إرسال.</div>
      </div>
    </div>

    <div id="submitMsg"></div>

    <form id="form">
      <div class="field">
        <div dir="ltr" lang="en" class="solve-grid" style="margin-top:10px">
          <div class="solve-left">
            <div id="blocklyArea" class="blockly-area" style="position:relative"></div>
          </div>
          <div class="solve-right">
            <div>
              <div class="row" style="justify-content:space-between;align-items:center;padding:10px 12px">
                <div class="row" style="gap:8px">
                  <select id="langSelect" class="input" style="width:auto">
                    <option value="python" selected>Python</option>
                  </select>
                  <select id="localeSelect" class="input" style="width:auto">
                    <option value="en" selected>English</option>
                  </select>
                </div>
                <div class="row" style="gap:8px">
                  <button class="btn" type="button" id="btnRun">Run</button>
                  <button class="btn" type="button" id="btnCopyPy">Copy</button>
                </div>
              </div>
              <textarea id="pyCode" class="input" style="height:650px;border:0;border-radius:0;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;direction:ltr" readonly></textarea>
            </div>
          </div>
        </div>
        <div class="muted" style="margin-top:10px">سيتم حفظ Workspace بصيغة XML + كود Python الناتج.</div>
        <input type="hidden" name="code_json" />
      </div>
    </form>
  </div>

  <div class="submit-area">
    <button class="btn primary submit-btn" type="submit" form="form">إرسال الحل</button>
  </div>
</div>

<div class="panel pad" style="margin-top:14px">
  <h3 style="margin:0 0 10px">النتيجة والتغذية الراجعة</h3>
  <div id="resultBox" class="muted">لم يتم التقديم بعد.</div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<script src="https://unpkg.com/blockly/python_compressed.js"></script>
<script src="https://unpkg.com/blockly/msg/en.js"></script>
<script>
  function qs(sel, root) { return (root || document).querySelector(sel); }
  function setText(el, text) { if (el) el.textContent = text; }
  function setHtml(el, html) { if (el) el.innerHTML = html; }
  function alertBox(type, msg) {
    const div = document.createElement('div');
    div.className = 'alert ' + type;
    div.textContent = msg;
    return div;
  }
  function badgeForResult(result) {
    if (result === 'success') return '<span class="tag">نجاح</span>';
    if (result === 'partial') return '<span class="tag">جزئي</span>';
    return '<span class="tag">فشل</span>';
  }
  function escapeHtml(str) {
    return String(str)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  const BLOCK_MAPPING = {
    init_variable: ["variables_set"],
    while_loop: ["controls_whileUntil"],
    print_text: ["text_print"],
    increment: ["math_change"],
    compare: ["logic_compare"],
    if_condition: ["controls_if"],
    add_subtract: ["math_arithmetic"],
    number_value: ["math_number"],
    text_value: ["text"],
    list_create: ["lists_create_with"],
    list_length: ["lists_length"],
    list_get: ["lists_getIndex"]
  };

  function normalizeRequiredBlocks(requiredBlocks) {
    if (Array.isArray(requiredBlocks)) {
      return requiredBlocks.map(String).map(s => s.trim()).filter(Boolean);
    }
    if (typeof requiredBlocks === 'string') {
      const raw = requiredBlocks.trim();
      if (!raw) return [];
      if ((raw.startsWith('[') && raw.endsWith(']')) || (raw.startsWith('"[') && raw.endsWith(']"'))) {
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            return parsed.map(String).map(s => s.trim()).filter(Boolean);
          }
        } catch {
          // ignore
        }
      }
      return raw.split(',').map(s => s.trim()).filter(Boolean);
    }
    return [];
  }

  function blockTypesForRequiredToken(token) {
    const t = String(token || '').trim().toLowerCase();
    if (!t) return [];
    if (Object.prototype.hasOwnProperty.call(BLOCK_MAPPING, t)) {
      const v = BLOCK_MAPPING[t];
      return Array.isArray(v) ? v : [];
    }
    if (t === 'loop' || t === 'while' || t === 'repeat') return ['controls_whileUntil', 'controls_repeat_ext'];
    if (t === 'if' || t === 'condition') return ['controls_if', 'logic_compare', 'logic_operation', 'logic_boolean'];
    if (t === 'print' || t === 'output') return ['text_print', 'text'];
    if (t === 'variable' || t === 'variables') return ['variables_set', 'variables_get', 'math_change'];
    if (t === 'math' || t === 'arithmetic' || t === 'number') return ['math_number', 'math_arithmetic'];
    if (t === 'text' || t === 'string') return ['text', 'text_join'];
    if (t === 'list' || t === 'lists' || t === 'array') return ['lists_create_with', 'lists_length', 'lists_getIndex', 'lists_setIndex'];
    if (t.includes('_')) return [token];
    return [];
  }

  function unique(arr) {
    const out = [];
    const seen = new Set();
    for (const x of arr) {
      if (!seen.has(x)) {
        out.push(x);
        seen.add(x);
      }
    }
    return out;
  }

  function buildToolboxFromChallenge(challenge) {
    const req = normalizeRequiredBlocks(challenge && challenge.required_blocks);
    challengeRequired = req;

    const allowedTypes = unique(req.flatMap(blockTypesForRequiredToken));
    const allowAll = allowedTypes.length === 0;

    // If Variables are allowed, also allow number blocks so learners can assign numeric values.
    // Without this, Math can disappear and "set x to" cannot receive a numeric input.
    const allowsVarsByType = allowAll || allowedTypes.some(t => String(t).startsWith('variables_')) || allowedTypes.includes('math_change');
    if (allowsVarsByType) {
      if (!allowedTypes.includes('math_number')) allowedTypes.push('math_number');
      if (!allowedTypes.includes('math_arithmetic')) allowedTypes.push('math_arithmetic');
    }

    function allow(type) {
      return allowAll || allowedTypes.includes(type);
    }

    const logicContents = [
      { "kind": "block", "type": "controls_if" },
      { "kind": "block", "type": "logic_compare" },
      { "kind": "block", "type": "logic_operation" },
      { "kind": "block", "type": "logic_boolean" }
    ].filter(b => allow(b.type));

    const loopsContents = [
      { "kind": "block", "type": "controls_repeat_ext", "inputs": { "TIMES": { "block": { "type": "math_number", "fields": { "NUM": 5 } } } } },
      { "kind": "block", "type": "controls_whileUntil" }
    ].filter(b => allow(b.type));

    const mathContents = [
      { "kind": "block", "type": "math_number" },
      { "kind": "block", "type": "math_arithmetic" },
      { "kind": "block", "type": "math_change" }
    ].filter(b => allow(b.type));

    const textContents = [
      { "kind": "block", "type": "text" },
      { "kind": "block", "type": "text_join" },
      { "kind": "block", "type": "text_print" }
    ].filter(b => allow(b.type));

    const listContents = [
      { "kind": "block", "type": "lists_create_with" },
      { "kind": "block", "type": "lists_length" },
      { "kind": "block", "type": "lists_getIndex" },
      { "kind": "block", "type": "lists_setIndex" }
    ].filter(b => allow(b.type));

    const contents = [];
    if (logicContents.length) contents.push({ "kind": "category", "name": "Logic", "categorystyle": "logic_category", "contents": logicContents });
    if (loopsContents.length) contents.push({ "kind": "category", "name": "Loops", "categorystyle": "loop_category", "contents": loopsContents });
    if (mathContents.length) contents.push({ "kind": "category", "name": "Math", "categorystyle": "math_category", "contents": mathContents });
    if (textContents.length) contents.push({ "kind": "category", "name": "Text", "categorystyle": "text_category", "contents": textContents });
    if (listContents.length) contents.push({ "kind": "category", "name": "Lists", "categorystyle": "list_category", "contents": listContents });

    const wantsVars = allowAll || allowedTypes.some(t => String(t).startsWith('variables_'));
    const wantsFns = allowAll || allowedTypes.some(t => String(t).startsWith('procedures_'));
    if (wantsVars) contents.push({ "kind": "category", "name": "Variables", "custom": "VARIABLE" });
    if (wantsFns) contents.push({ "kind": "category", "name": "Functions", "custom": "PROCEDURE" });

    return { "kind": "categoryToolbox", "contents": contents.length ? contents : [{ "kind": "category", "name": "Text", "categorystyle": "text_category", "contents": [{ "kind": "block", "type": "text_print" }, { "kind": "block", "type": "text" }] }] };
  }

  function getUsedBlocklyTypes(ws) {
    try {
      const blocks = ws.getAllBlocks(false);
      return new Set(blocks.map(b => b.type));
    } catch {
      return new Set();
    }
  }

  function validateRequiredBlocks(ws, requiredTokens) {
    const req = normalizeRequiredBlocks((requiredTokens || []).join(','));
    if (!req.length) return { ok: true, missing: [] };
    const used = getUsedBlocklyTypes(ws);

    const missing = [];
    for (const token of req) {
      const types = blockTypesForRequiredToken(token);
      if (!types.length) continue;
      const satisfied = types.some(t => used.has(t));
      if (!satisfied) missing.push(token);
    }
    return { ok: missing.length === 0, missing };
  }

  const AUTH_KEY = 'smart_platform_auth';
  function getAuth() {
    try {
      const raw = localStorage.getItem(AUTH_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }

  async function requestJson(path, opts) {
    const o = opts || {};
    const res = await fetch(path, {
      method: o.method || 'GET',
      headers: { 'Content-Type': 'application/json' },
      body: o.body ? JSON.stringify(o.body) : undefined,
    });
    const text = await res.text();
    let data;
    try { data = text ? JSON.parse(text) : {}; } catch { data = { raw: text }; }
    if (!res.ok) {
      const msg = (data && data.error) ? data.error : ('HTTP ' + res.status);
      const err = new Error(msg);
      err.status = res.status;
      err.data = data;
      throw err;
    }
    return data;
  }

  const api = {
    getChallenge: (id) => requestJson('/challenges/' + encodeURIComponent(id)),
    submit: (payload) => requestJson('/submit', { method: 'POST', body: payload }),
  };

  const auth = getAuth();
  const msg = qs('#msg');
  const submitMsg = qs('#submitMsg');
  const form = qs('#form');
  const titleEl = qs('#title');
  const metaEl = qs('#meta');
  const descEl = qs('#desc');
  const badgesEl = qs('#badges');
  const resultBox = qs('#resultBox');
  const blocklyArea = qs('#blocklyArea');
  const pyCode = qs('#pyCode');
  const btnCopyPy = qs('#btnCopyPy');
  const btnRun = qs('#btnRun');
  let workspace = null;
  let challengeRequired = [];

  const params = new URLSearchParams(window.location.search);
  const id = params.get('id');

  if (!id) {
    msg.appendChild(alertBox('error', 'معرّف التحدي غير موجود في الرابط.'));
  }

  async function loadChallenge() {
    try {
      const c = await api.getChallenge(id);
      setText(titleEl, c.title || 'تحدي');
      setText(descEl, c.description || '');
      setText(metaEl, `${c.concept || ''} • ${c.difficulty || ''}`.trim());

      const badges = [];
      if (c.concept) badges.push(`<span class="tag">${escapeHtml(c.concept)}</span>`);
      if (c.difficulty) badges.push(`<span class="tag">${escapeHtml(c.difficulty)}</span>`);
      if (c.json_template) badges.push(`<span class="tag">قالب</span>`);
      setHtml(badgesEl, badges.join(''));

      // تهيئة Blockly (toolbox حسب التحدي)
      const toolbox = buildToolboxFromChallenge(c);

      if (!workspace && blocklyArea && window.Blockly) {
        workspace = Blockly.inject(blocklyArea, {
          toolbox,
          rtl: false,
          scrollbars: true,
          trashcan: true,
          zoom: {
            controls: true,
            wheel: true,
            startScale: 1.3,
            maxScale: 2.5,
            minScale: 0.8,
            scaleSpeed: 1.2
          },
        });

        // HARD enforcement: make blocks large by default and force SVG resize.
        try {
          workspace.setScale(1.3);
          // HARD enforcement: force toolbox + flyout widths (CSS + JS) and reflow.
          const toolboxDiv = document.querySelector('#blocklyArea .blocklyToolboxDiv');
          if (toolboxDiv) toolboxDiv.style.width = '280px';
          const flyoutDiv = document.querySelector('#blocklyArea .blocklyFlyout');
          if (flyoutDiv) flyoutDiv.style.width = '360px';
          const flyoutBg = document.querySelector('#blocklyArea .blocklyFlyoutBackground');
          if (flyoutBg) {
            flyoutBg.style.width = '360px';
            flyoutBg.setAttribute('width', '360');
          }
          Blockly.svgResize(workspace);
          if (workspace.scrollCenter) workspace.scrollCenter();
        } catch {
          // ignore
        }

        window.addEventListener('resize', () => {
          try { Blockly.svgResize(workspace); } catch { /* ignore */ }
        });

        // Live sync: blocks -> python
        const updatePython = () => {
          try {
            if (!pyCode) return;
            if (!Blockly.Python) {
              pyCode.value = '# Python generator not loaded.';
              return;
            }
            const code = Blockly.Python.workspaceToCode(workspace);
            pyCode.value = code || '';
          } catch (e) {
            if (pyCode) pyCode.value = '# Error generating Python.';
          }
        };

        workspace.addChangeListener(updatePython);
        updatePython();
      }

      // إذا كان قالب التحدي مخزن كـ Blockly XML داخل json_template
      if (workspace && c.json_template) {
        try {
          const parsed = JSON.parse(c.json_template);
          if (parsed && parsed.blockly_xml) {
            const dom = Blockly.Xml.textToDom(parsed.blockly_xml);
            Blockly.Xml.domToWorkspace(dom, workspace);
          }
        } catch {
          // ignore
        }
      }

      // Ensure workspace reflows correctly after any XML load
      try {
        if (workspace) Blockly.svgResize(workspace);
      } catch {
        // ignore
      }

      // ensure python is updated after loading template
      try {
        if (workspace && Blockly.Python && pyCode) {
          pyCode.value = Blockly.Python.workspaceToCode(workspace) || '';
        }
      } catch {
        // ignore
      }
    } catch (err) {
      msg.appendChild(alertBox('error', err.message || 'فشل تحميل التحدي'));
    }
  }

  if (btnCopyPy) {
    btnCopyPy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(pyCode ? (pyCode.value || '') : '');
      } catch {
        // ignore
      }
    });
  }

  if (btnRun) {
    btnRun.addEventListener('click', () => {
      submitMsg.innerHTML = '';
      submitMsg.appendChild(alertBox('warn', 'تشغيل Python داخل المتصفح غير مفعّل الآن. يمكنك نسخ الكود أو إرسال الحل.'));
    });
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    submitMsg.innerHTML = '';

    if (!auth) {
      submitMsg.appendChild(alertBox('warn', 'يجب تسجيل الدخول للتقديم.'));
      return;
    }

    if (!workspace || !window.Blockly) {
      submitMsg.appendChild(alertBox('error', 'تعذر تحميل محرر Blockly.'));
      return;
    }

    const validation = (typeof validateRequiredBlocks === 'function') ? validateRequiredBlocks(workspace, challengeRequired) : { ok: true, missing: [] };
    if (!validation.ok) {
      submitMsg.appendChild(alertBox('warn', 'الرجاء استخدام الكتل المطلوبة في هذا التحدي: ' + validation.missing.join(', ')));
      return;
    }

    // Serialize workspace to XML and wrap into code_json
    const xmlDom = Blockly.Xml.workspaceToDom(workspace);
    const xmlText = Blockly.Xml.domToText(xmlDom);
    let python = '';
    try {
      python = (Blockly.Python && Blockly.Python.workspaceToCode) ? (Blockly.Python.workspaceToCode(workspace) || '') : '';
    } catch {
      python = '';
    }
    const wrapped = { blockly_xml: xmlText, python_code: python };
    form.code_json.value = JSON.stringify(wrapped);

    const payload = {
      username: auth.username,
      challenge_id: Number(id),
      code_json: form.code_json.value,
    };

    try {
      const res = await api.submit(payload);
      submitMsg.appendChild(alertBox('success', 'تم إرسال الحل وحفظ المحاولة.'));
      resultBox.classList.remove('muted');
      resultBox.innerHTML = `
        <div class="row" style="justify-content:space-between;">
          <div><strong>الطالب:</strong> ${escapeHtml(res.student || auth.username)}</div>
          <div>${badgeForResult(res.result)}</div>
        </div>
        <div style="margin-top:10px; white-space:pre-wrap">${escapeHtml(res.feedback || '')}</div>
      `;
    } catch (err) {
      submitMsg.appendChild(alertBox('error', err.message || 'فشل التقديم'));
    }
  });

  loadChallenge();
</script>
{% endblock %}
